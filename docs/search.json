[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Purpose",
    "section": "",
    "text": "This website serves as a platform to showcase the projects I’ve worked on. My hope is that they will contribute to achieving a Pareto optimal solution, in the sense that they may be of use to others and is free for me to share."
  },
  {
    "objectID": "index.html#languages",
    "href": "index.html#languages",
    "title": "Purpose",
    "section": "Languages",
    "text": "Languages\nI am native Danish, so it is possible that some of the content will be in Danish.\nThis also means that the English may not always be flawless"
  },
  {
    "objectID": "projects.html",
    "href": "projects.html",
    "title": "Projects",
    "section": "",
    "text": "Here are some of my projects:\n\nMixture of K scaled and shifted t distributions\n\nMixture of K scaled and shifted t distributions\n\nThe implementation is made using a combination of R and C++ via the Rcpp library.\n\n\nVP-search trees for cgMLST sequences\n\nVP-search trees for cgMLST sequences\n\nThe implementation is made in python and the report is written in jupyter notebooks.\n\n\nBee a Spelling Genius\n\nBee a Spelling Genius\n\nThis is a live application made with the Shiny for Python version. The intention was to create a small project and learn about reactive programming, as well as how to develop small applications and dashboards. By using Shiny for Python, I could run it directly on my GitHub page, making it easier to share with others."
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "I’m interested in the topics of economics, machine learning(prediction), statistics(inference), and coding."
  },
  {
    "objectID": "about.html#my-background",
    "href": "about.html#my-background",
    "title": "About",
    "section": "My background",
    "text": "My background\nMaster of Science (statistics)\nBachelor math economics\nBoth from University of Copenhagen(KU)"
  },
  {
    "objectID": "Bee_a_Spelling_Guinness.html",
    "href": "Bee_a_Spelling_Guinness.html",
    "title": "Projects",
    "section": "",
    "text": "Here are some of my projects:\n\nMixture of K scaled and shifted t distributions\n\nMixture of K scaled and shifted t distributions\n\nThe implementation is made using a combination of R and C++ via the Rcpp library.\n\n\nVP-search trees for cgMLST sequences\n\nVP-search trees for cgMLST sequences\n\nThe implementation is made in python and the report is written in jupyter notebooks."
  },
  {
    "objectID": "docs/projects.html",
    "href": "docs/projects.html",
    "title": "Projects",
    "section": "",
    "text": "Here are some of my projects:\n\nMixture of K scaled and shifted t distributions\n\nMixture of K scaled and shifted t distributions\n\nThe implementation is made using a combination of R and C++ via the Rcpp library.\n\n\nVP-search trees for cgMLST sequences\n\nVP-search trees for cgMLST sequences\n\nThe implementation is made in python and the report is written in jupyter notebooks."
  },
  {
    "objectID": "aplications.html",
    "href": "aplications.html",
    "title": "Applications",
    "section": "",
    "text": "For now, this site contains only one application built with Shiny. I may extend it in the future if I create more."
  },
  {
    "objectID": "aplications.html#about",
    "href": "aplications.html#about",
    "title": "Applications",
    "section": "About",
    "text": "About\nThis is a interactive app made to, help/improve player’s of New York times Spelling Bee.\nIn the spelling bee, the player is given seven letters. One letter is marked in yellow.\nThe goal is to make as many words as possible from the seven letters. Every word should contain the yellow letter.\nScoring\n\nA word of 4 letters earns one point.\nWords longer than 4 letters earn additional points (the exact amount is to be determined).\n\nThe dictionary used is provided Here under an open license.\nThe Spelling Bee uses a list of curated words. The dictionary is more like a reference for how words are spelled. For example, “AAAA” might appear in the dictionary but is unlikely to be included in the Spelling Bee.\nThere may also be words that are offensive or outdated. While they are correctly spelled, they probably won’t appear in the Spelling Bee."
  },
  {
    "objectID": "aplications.html#version-with-the-code",
    "href": "aplications.html#version-with-the-code",
    "title": "Applications",
    "section": "Version with the code",
    "text": "Version with the code\nHere is a version where the code can be seen\n#| '!! shinylive warning !!': |\n#|   shinylive does not work in self-contained HTML documents.\n#|   Please set `embed-resources: false` in your metadata.\n#| standalone: true\n#| viewerHeight: 800\n#| components: [editor, viewer]\n\nfrom shiny import *\n# For plot\nimport matplotlib.pyplot as plt\n# Get all words in the english diconary\nimport numpy as np\nimport requests\n# URL of the text file on GitHub\nurl = \"https://raw.githubusercontent.com/dwyl/english-words/refs/heads/master/words.txt\"\n\n# Fetch the file content\nresponse = requests.get(url)\n\nif response.status_code == 200:\n    # Read the content of the file\n    file_content = response.text\n    # Split the content into a list of words\n    words_list = file_content.splitlines()\n    print(words_list)\nelse:\n    print(\"Failed to retrieve the file:\", response.status_code)\n\ndef check_word_canidat_early_stopping(\n        word:str,\n        yellow_chr:chr,\n        chr_list:list):\n    \"\"\"\n    This function return True ore False.\n    To be valid candidat a get true retrun, the input word\n    need to contain the yellow chr, and can not contain other chr that yellow and chr from the list of charater list\n    \n    Args:\n        word (str): The word that need to be ckecked.\n        yellow_chr (chr): a chr that all word must contain\n        chr_list (list): a list of chr that the word can be contain in.\n    Returns:\n        bool: True ore False based on if the word forfiels the conditions\n   \n    \"\"\"\n    lover_yellow =yellow_chr.lower()\n    return_obj=False\n    is_word_combination_of_chr_list=False\n    is_yellow_chr_contained= False\n    lower_chars = [char.lower() for char in chr_list]\n    \n    for letter in word:\n        is_letter_contained= letter.lower() in lower_chars\n        if (is_letter_contained==False):\n            is_word_combination_of_chr_list=False\n            break\n        else:\n            is_word_combination_of_chr_list=True\n        if (is_yellow_chr_contained==False):\n            is_yellow_chr_contained=(lover_yellow==letter.lower())\n    \n    if(is_word_combination_of_chr_list==True and is_yellow_chr_contained==True):\n        return_obj =True\n    return return_obj\n\n\n\ndef get_word_candidates(\n        word_list:list,\n        yellow_chr: chr,\n        chr_list:list,\n        min_word_length:int = 4):\n    \"\"\"\n    This returns list containg alle candidat words, for the spelling bee game.\n\n    All word contain the yellow letter, and consist of combination yello and letter from the letter list.\n    All words is longer ore equal to min_word_length\n    \n    Args:\n        word_list (list): a list with string containg words to serach though\n        yellow_chr (chr): all word in return should contain this letter\n        chr_list (list): a list of chr that can be conatin a word in return\n    Returns:\n        list: a list of strings. all word should be combination of yellow chr and letter from the list.\n        \n    \"\"\"\n    return_objet = []\n    index_list=[] #this list contais the index of wich words is potensiel words in the index list.\n    allowed_chartes= chr_list + [yellow_chr]\n    # len word is not calculated but store in the type string so it fast to check if len of the word is les than min first\n    for i in range(len(word_list)):\n        word_for_examination=word_list[i]\n        if(len(word_for_examination)&gt;=min_word_length):\n            if(check_word_canidat_early_stopping(word_for_examination,yellow_chr,allowed_chartes)==True):\n                return_objet.append(word_for_examination)\n                index_list.append(i)\n    return(return_objet)\n\n\n# Generat plots\n\ndef get_len_word_list(words_list:int):\n    list_len=[]\n    for word in words_list: list_len.append(len(word))\n    return list_len\n\n\n\n\n# Define the app UI\napp_ui = ui.page_fluid(\n    ui.input_selectize(\"yellow_chr\", \"Choose one yellow letter\", \n                       [\"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\", \"H\", \"I\", \"J\", \"K\", \"L\", \"M\", \"N\", \"O\", \"P\", \"Q\", \"R\", \"S\", \"T\", \"U\", \"V\", \"W\", \"X\", \"Y\", \"Z\"], \n                       multiple=False),\n    ui.output_text_verbatim(\"yellow_chr_output\"),\n    ui.input_selectize(\"grey_chr\", \"Choose six grey letters\", \n                       [\"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\", \"H\", \"I\", \"J\", \"K\", \"L\", \"M\", \"N\", \"O\", \"P\", \"Q\", \"R\", \"S\", \"T\", \"U\", \"V\", \"W\", \"X\", \"Y\", \"Z\"], \n                       multiple=True),\n    ui.output_text_verbatim(\"grey_chr_output\"),\n    ui.output_text_verbatim(\"len_data_txt\"),\n    ui.output_plot(\"plot\"),\n    ui.output_ui(\"output_content\"),\n    ui.input_switch(\"switch\", \"Show word results\", False),  \n    ui.output_text_verbatim(\"word_list_output\")\n)\n\n# Define the app server logic\ndef server(input, output, session):\n    @reactive.Calc\n    def dataset():\n        # This function returns a dataset when 6 grey letters are selected\n        if len(input.grey_chr()) == 6:\n            return get_word_candidates(words_list, input.yellow_chr(),list(input.grey_chr()))\n        else:\n            return []\n    @reactive.Calc\n    def len_data():\n        len_data=get_len_word_list(dataset())\n        return len_data\n        \n    @output\n    @render.text\n    def yellow_chr_output():\n        return f\"The chosen yellow letter is {input.yellow_chr()}\"\n    @output\n    @render.text\n    def grey_chr_output():\n        if len(input.grey_chr()) != 6:\n            return f\"You need to choose 6 grey letters; currently, you have chosen {len(input.grey_chr())}.\"\n        else:\n            return \"You have chosen 6 grey letters.\"\n    @output\n    @render.text\n    def len_data_txt():\n        ret_ob=\"The data has not bin computed\"\n        if(len(input.grey_chr())==6):\n            ret_ob=f\"There are {len(dataset())} possible words with 4 or more letters\"\n        return ret_ob\n    @output\n    @render.plot(alt=\"A histogram of dataset values\")\n    def plot():    \n        fig, ax = plt.subplots()\n        if len(input.grey_chr()) == 6:\n            unique_values, counts = np.unique(len_data(), return_counts=True)\n            ax.bar(unique_values, counts, color='skyblue', edgecolor='black')\n            ax.set_title(\"Histogram of Word Candidates\")\n            ax.set_xlabel(\"Length of word\")\n            ax.set_ylabel(\"Count\")\n        else:\n            ax.text(0.5, 0.5, \"Please select 6 grey letters\", horizontalalignment='center', verticalalignment='center')\n        return fig\n    @output\n    @render.text\n    def word_list_output():\n        ret_ob=\"\"\n        if(input.switch()==True):\n            ret_ob=\"\\n\".join(dataset())\n        return ret_ob\n        \n    \n\napp = App(app_ui, server)"
  },
  {
    "objectID": "aplications.html#made-with-shiny-for-python-shiny-live",
    "href": "aplications.html#made-with-shiny-for-python-shiny-live",
    "title": "Applications",
    "section": "Made with Shiny for Python (Shiny Live)",
    "text": "Made with Shiny for Python (Shiny Live)\nThis application is created using Shiny for Python (Shiny Live). There is also an R version available.\nWhat makes the Shiny Live version so appealing is that it allows embedding Python code into WebAssembly. This application runs Python directly from your personal computer, with the dictionary downloaded from a GitHub link.\nThe library support is somewhat limited.\nFor small projects that should be accessible to the public, I like Shiny Live because it doesn’t require hosting a server for the backend.\nEstially the backend runs on you pc.\nTheir is som drawback, every aplication need the data to load in seperatly. Alle code and data is exeable for the user, documentasion is spars. It hard to debug, since it reaktiv programing."
  },
  {
    "objectID": "applications.html",
    "href": "applications.html",
    "title": "Applications",
    "section": "",
    "text": "For now, this site contains only one application built with Shiny. I may extend it in the future if I create more."
  },
  {
    "objectID": "applications.html#about",
    "href": "applications.html#about",
    "title": "Applications",
    "section": "About",
    "text": "About\nThis is a interactive app made to, help/improve player’s of New York times Spelling Bee.\nIn the spelling bee, the player is given seven letters. One letter is marked in yellow.\nThe goal is to make as many words as possible from the seven letters. Every word should contain the yellow letter.\nScoring\n\nA word of 4 letters earns one point.\nWords longer than 4 letters earn additional points (the exact amount is to be determined).\n\nThe dictionary used is provided Here under an open license.\nThe Spelling Bee uses a list of curated words. The dictionary is more like a reference for how words are spelled. For example, “AAAA” might appear in the dictionary but is unlikely to be included in the Spelling Bee.\nThere may also be words that are offensive or outdated. While they are correctly spelled, they probably won’t appear in the Spelling Bee.\n#| '!! shinylive warning !!': |\n#|   shinylive does not work in self-contained HTML documents.\n#|   Please set `embed-resources: false` in your metadata.\n#| standalone: true\n#| viewerHeight: 800\n\n\nfrom shiny import *\n# For plot\nimport matplotlib.pyplot as plt\n# Get all words in the english diconary\nimport numpy as np\nimport requests\n# URL of the text file on GitHub\nurl = \"https://raw.githubusercontent.com/dwyl/english-words/refs/heads/master/words.txt\"\n\n# Fetch the file content\nresponse = requests.get(url)\n\nif response.status_code == 200:\n    # Read the content of the file\n    file_content = response.text\n    # Split the content into a list of words\n    words_list = file_content.splitlines()\n    print(words_list)\nelse:\n    print(\"Failed to retrieve the file:\", response.status_code)\n\ndef check_word_canidat_early_stopping(\n        word:str,\n        yellow_chr:chr,\n        chr_list:list):\n    \"\"\"\n    This function return True ore False.\n    To be valid candidat a get true retrun, the input word\n    need to contain the yellow chr, and can not contain other chr that yellow and chr from the list of charater list\n    \n    Args:\n        word (str): The word that need to be ckecked.\n        yellow_chr (chr): a chr that all word must contain\n        chr_list (list): a list of chr that the word can be contain in.\n    Returns:\n        bool: True ore False based on if the word forfiels the conditions\n    \"\"\"\n    lover_yellow =yellow_chr.lower()\n    return_obj=False\n    is_word_combination_of_chr_list=False\n    is_yellow_chr_contained= False\n    lower_chars = [char.lower() for char in chr_list]\n    \n    for letter in word:\n        is_letter_contained= letter.lower() in lower_chars\n        if (is_letter_contained==False):\n            is_word_combination_of_chr_list=False\n            break\n        else:\n            is_word_combination_of_chr_list=True\n        if (is_yellow_chr_contained==False):\n            is_yellow_chr_contained=(lover_yellow==letter.lower())\n    \n    if(is_word_combination_of_chr_list==True and is_yellow_chr_contained==True):\n        return_obj =True\n    return return_obj\n\n\n\ndef get_word_candidates(\n        word_list:list,\n        yellow_chr: chr,\n        chr_list:list,\n        min_word_length:int = 4):\n    \"\"\"\n    This returns list containg alle candidat words, for the spelling bee game.\n\n    All word contain the yellow letter, and consist of combination yello and letter from the letter list.\n    All words is longer ore equal to min_word_length\n    \n    Args:\n        word_list (list): a list with string containg words to serach though\n        yellow_chr (chr): all word in return should contain this letter\n        chr_list (list): a list of chr that can be conatin a word in return\n    Returns:\n        list: a list of strings. all word should be combination of yellow chr and letter from the list.\n        \n    \"\"\"\n    return_objet = []\n    index_list=[] #this list contais the index of wich words is potensiel words in the index list.\n    allowed_chartes= chr_list + [yellow_chr]\n    # len word is not calculated but store in the type string so it fast to check if len of the word is les than min first\n    for i in range(len(word_list)):\n        word_for_examination=word_list[i]\n        if(len(word_for_examination)&gt;=min_word_length):\n            if(check_word_canidat_early_stopping(word_for_examination,yellow_chr,allowed_chartes)==True):\n                return_objet.append(word_for_examination)\n                index_list.append(i)\n    return(return_objet)\n\n\n# Generat plots\n\ndef get_len_word_list(words_list:int):\n    list_len=[]\n    for word in words_list: list_len.append(len(word))\n    return list_len\n\n\n\n\n# Define the app UI\napp_ui = ui.page_fluid(\n    ui.input_selectize(\"yellow_chr\", \"Choose one yellow letter\", \n                       [\"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\", \"H\", \"I\", \"J\", \"K\", \"L\", \"M\", \"N\", \"O\", \"P\", \"Q\", \"R\", \"S\", \"T\", \"U\", \"V\", \"W\", \"X\", \"Y\", \"Z\"], \n                       multiple=False),\n    ui.output_text_verbatim(\"yellow_chr_output\"),\n    ui.input_selectize(\"grey_chr\", \"Choose six grey letters\", \n                       [\"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\", \"H\", \"I\", \"J\", \"K\", \"L\", \"M\", \"N\", \"O\", \"P\", \"Q\", \"R\", \"S\", \"T\", \"U\", \"V\", \"W\", \"X\", \"Y\", \"Z\"], \n                       multiple=True),\n    ui.output_text_verbatim(\"grey_chr_output\"),\n    ui.output_text_verbatim(\"len_data_txt\"),\n    ui.output_plot(\"plot\"),\n    ui.output_ui(\"output_content\"),\n    ui.input_switch(\"switch\", \"Show word results\", False),  \n    ui.output_text_verbatim(\"word_list_output\")\n)\n\n# Define the app server logic\ndef server(input, output, session):\n    @reactive.Calc\n    def dataset():\n        # This function returns a dataset when 6 grey letters are selected\n        if len(input.grey_chr()) == 6:\n            return get_word_candidates(words_list, input.yellow_chr(),list(input.grey_chr()))\n        else:\n            return []\n    @reactive.Calc\n    def len_data():\n        len_data=get_len_word_list(dataset())\n        return len_data\n        \n    @output\n    @render.text\n    def yellow_chr_output():\n        return f\"The chosen yellow letter is {input.yellow_chr()}\"\n    @output\n    @render.text\n    def grey_chr_output():\n        if len(input.grey_chr()) != 6:\n            return f\"You need to choose 6 grey letters; currently, you have chosen {len(input.grey_chr())}.\"\n        else:\n            return \"You have chosen 6 grey letters.\"\n    @output\n    @render.text\n    def len_data_txt():\n        ret_ob=\"The data has not bin computed\"\n        if(len(input.grey_chr())==6):\n            ret_ob=f\"There are {len(dataset())} possible words with 4 or more letters\"\n        return ret_ob\n    @output\n    @render.plot(alt=\"A histogram of dataset values\")\n    def plot():    \n        fig, ax = plt.subplots()\n        if len(input.grey_chr()) == 6:\n            unique_values, counts = np.unique(len_data(), return_counts=True)\n            ax.bar(unique_values, counts, color='skyblue', edgecolor='black')\n            ax.set_title(\"Histogram of Word Candidates\")\n            ax.set_xlabel(\"Length of word\")\n            ax.set_ylabel(\"Count\")\n        else:\n            ax.text(0.5, 0.5, \"Please select 6 grey letters\", horizontalalignment='center', verticalalignment='center')\n        return fig\n    @output\n    @render.text\n    def word_list_output():\n        ret_ob=\"\"\n        if(input.switch()==True):\n            ret_ob=\"\\n\".join(dataset())\n        return ret_ob\n        \n    \n\napp = App(app_ui, server)"
  },
  {
    "objectID": "applications.html#version-with-the-code",
    "href": "applications.html#version-with-the-code",
    "title": "Applications",
    "section": "Version with the code",
    "text": "Version with the code\nHere is a version where the code can be seen\n#| '!! shinylive warning !!': |\n#|   shinylive does not work in self-contained HTML documents.\n#|   Please set `embed-resources: false` in your metadata.\n#| standalone: true\n#| viewerHeight: 800\n#| components: [editor, viewer]\n\nfrom shiny import *\n# For plot\nimport matplotlib.pyplot as plt\n# Get all words in the english diconary\nimport numpy as np\nimport requests\n# URL of the text file on GitHub\nurl = \"https://raw.githubusercontent.com/dwyl/english-words/refs/heads/master/words.txt\"\n\n# Fetch the file content\nresponse = requests.get(url)\n\nif response.status_code == 200:\n    # Read the content of the file\n    file_content = response.text\n    # Split the content into a list of words\n    words_list = file_content.splitlines()\n    print(words_list)\nelse:\n    print(\"Failed to retrieve the file:\", response.status_code)\n\ndef check_word_canidat_early_stopping(\n        word:str,\n        yellow_chr:chr,\n        chr_list:list):\n    \"\"\"\n    This function return True ore False.\n    To be valid candidat a get true retrun, the input word\n    need to contain the yellow chr, and can not contain other chr that yellow and chr from the list of charater list\n    \n    Args:\n        word (str): The word that need to be ckecked.\n        yellow_chr (chr): a chr that all word must contain\n        chr_list (list): a list of chr that the word can be contain in.\n    Returns:\n        bool: True ore False based on if the word forfiels the conditions\n   \n    \"\"\"\n    lover_yellow =yellow_chr.lower()\n    return_obj=False\n    is_word_combination_of_chr_list=False\n    is_yellow_chr_contained= False\n    lower_chars = [char.lower() for char in chr_list]\n    \n    for letter in word:\n        is_letter_contained= letter.lower() in lower_chars\n        if (is_letter_contained==False):\n            is_word_combination_of_chr_list=False\n            break\n        else:\n            is_word_combination_of_chr_list=True\n        if (is_yellow_chr_contained==False):\n            is_yellow_chr_contained=(lover_yellow==letter.lower())\n    \n    if(is_word_combination_of_chr_list==True and is_yellow_chr_contained==True):\n        return_obj =True\n    return return_obj\n\n\n\ndef get_word_candidates(\n        word_list:list,\n        yellow_chr: chr,\n        chr_list:list,\n        min_word_length:int = 4):\n    \"\"\"\n    This returns list containg alle candidat words, for the spelling bee game.\n\n    All word contain the yellow letter, and consist of combination yello and letter from the letter list.\n    All words is longer ore equal to min_word_length\n    \n    Args:\n        word_list (list): a list with string containg words to serach though\n        yellow_chr (chr): all word in return should contain this letter\n        chr_list (list): a list of chr that can be conatin a word in return\n    Returns:\n        list: a list of strings. all word should be combination of yellow chr and letter from the list.\n        \n    \"\"\"\n    return_objet = []\n    index_list=[] #this list contais the index of wich words is potensiel words in the index list.\n    allowed_chartes= chr_list + [yellow_chr]\n    # len word is not calculated but store in the type string so it fast to check if len of the word is les than min first\n    for i in range(len(word_list)):\n        word_for_examination=word_list[i]\n        if(len(word_for_examination)&gt;=min_word_length):\n            if(check_word_canidat_early_stopping(word_for_examination,yellow_chr,allowed_chartes)==True):\n                return_objet.append(word_for_examination)\n                index_list.append(i)\n    return(return_objet)\n\n\n# Generat plots\n\ndef get_len_word_list(words_list:int):\n    list_len=[]\n    for word in words_list: list_len.append(len(word))\n    return list_len\n\n\n\n\n# Define the app UI\napp_ui = ui.page_fluid(\n    ui.input_selectize(\"yellow_chr\", \"Choose one yellow letter\", \n                       [\"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\", \"H\", \"I\", \"J\", \"K\", \"L\", \"M\", \"N\", \"O\", \"P\", \"Q\", \"R\", \"S\", \"T\", \"U\", \"V\", \"W\", \"X\", \"Y\", \"Z\"], \n                       multiple=False),\n    ui.output_text_verbatim(\"yellow_chr_output\"),\n    ui.input_selectize(\"grey_chr\", \"Choose six grey letters\", \n                       [\"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\", \"H\", \"I\", \"J\", \"K\", \"L\", \"M\", \"N\", \"O\", \"P\", \"Q\", \"R\", \"S\", \"T\", \"U\", \"V\", \"W\", \"X\", \"Y\", \"Z\"], \n                       multiple=True),\n    ui.output_text_verbatim(\"grey_chr_output\"),\n    ui.output_text_verbatim(\"len_data_txt\"),\n    ui.output_plot(\"plot\"),\n    ui.output_ui(\"output_content\"),\n    ui.input_switch(\"switch\", \"Show word results\", False),  \n    ui.output_text_verbatim(\"word_list_output\")\n)\n\n# Define the app server logic\ndef server(input, output, session):\n    @reactive.Calc\n    def dataset():\n        # This function returns a dataset when 6 grey letters are selected\n        if len(input.grey_chr()) == 6:\n            return get_word_candidates(words_list, input.yellow_chr(),list(input.grey_chr()))\n        else:\n            return []\n    @reactive.Calc\n    def len_data():\n        len_data=get_len_word_list(dataset())\n        return len_data\n        \n    @output\n    @render.text\n    def yellow_chr_output():\n        return f\"The chosen yellow letter is {input.yellow_chr()}\"\n    @output\n    @render.text\n    def grey_chr_output():\n        if len(input.grey_chr()) != 6:\n            return f\"You need to choose 6 grey letters; currently, you have chosen {len(input.grey_chr())}.\"\n        else:\n            return \"You have chosen 6 grey letters.\"\n    @output\n    @render.text\n    def len_data_txt():\n        ret_ob=\"The data has not bin computed\"\n        if(len(input.grey_chr())==6):\n            ret_ob=f\"There are {len(dataset())} possible words with 4 or more letters\"\n        return ret_ob\n    @output\n    @render.plot(alt=\"A histogram of dataset values\")\n    def plot():    \n        fig, ax = plt.subplots()\n        if len(input.grey_chr()) == 6:\n            unique_values, counts = np.unique(len_data(), return_counts=True)\n            ax.bar(unique_values, counts, color='skyblue', edgecolor='black')\n            ax.set_title(\"Histogram of Word Candidates\")\n            ax.set_xlabel(\"Length of word\")\n            ax.set_ylabel(\"Count\")\n        else:\n            ax.text(0.5, 0.5, \"Please select 6 grey letters\", horizontalalignment='center', verticalalignment='center')\n        return fig\n    @output\n    @render.text\n    def word_list_output():\n        ret_ob=\"\"\n        if(input.switch()==True):\n            ret_ob=\"\\n\".join(dataset())\n        return ret_ob\n        \n    \n\napp = App(app_ui, server)"
  },
  {
    "objectID": "applications.html#made-with-shiny-for-python-shiny-live",
    "href": "applications.html#made-with-shiny-for-python-shiny-live",
    "title": "Applications",
    "section": "Made with Shiny for Python (Shiny Live)",
    "text": "Made with Shiny for Python (Shiny Live)\nThis application is created using Shiny for Python (Shiny Live). There is also an R version available.\nWhat makes the Shiny Live version so appealing is that it allows embedding Python code into WebAssembly. This application runs Python directly from your personal computer, with the dictionary downloaded from a GitHub link.\nThe library support is somewhat limited.\nFor small projects that should be accessible to the public, I like Shiny Live because it doesn’t require hosting a server for the backend.\nEstially the backend runs on you pc.\nTheir is som drawback, every aplication need the data to load in seperatly. Alle code and data is exeable for the user, documentasion is spars. It hard to debug, since it reaktiv programing.\nBut overall, being able to create applications without needing to host a server is pretty cool."
  }
]