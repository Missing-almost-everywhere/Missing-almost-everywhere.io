[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Purpose",
    "section": "",
    "text": "This website serves as a platform to showcase the projects I’ve worked on. My hope is that they will contribute to achieving a Pareto optimal solution, in the sense that they may be of use to others and is free for me to share."
  },
  {
    "objectID": "index.html#languages",
    "href": "index.html#languages",
    "title": "Purpose",
    "section": "Languages",
    "text": "Languages\nI am native Danish, so it is possible that some of the content will be in Danish.\nThis also means that the English may not always be flawless"
  },
  {
    "objectID": "projects.html",
    "href": "projects.html",
    "title": "Projects",
    "section": "",
    "text": "Here are some of my projects:\n\nA Toy Model for Market Dynamics: Building a Agent-Based Frameworks\nA Toy Model for Market Dynamics: Building a Agent-Based Frameworks\nThis project explores the foundational concepts of agent-based simulations through a simplified market model. Using Python, it simulates shoppers navigating a fictional representation of Strøget, Copenhagen’s shopping district. Each shopper is modeled as an agent with specific preferences, budget constraints, and behaviors, while shops act as agents offering products in distinct categories.\nThe project emphasizes structural design choices, such as implementing interactions (e.g., buying decisions) and tracking aggregated metrics like total sales. It also addresses technical challenges, including managing dynamic effects and considering potential parallelization issues, though these aspects have not yet been fully implemented.\nThe implementation is written in Python and includes unit tests to verify the functionality of key components. Primarily intended as a learning exercise, this model aims to refine object-oriented programming skills and simulate agent interactions. It serves as a foundation for exploring more complex systems and optimizing efficiency in future iterations.\n\n\nBee a Spelling Genius\nBee a Spelling Genius\nThis is a live application made with the Shiny for Python version.\nThe intention was to create a small project and learn about reactive programming, as well as how to develop small applications and dashboards. By using Shiny for Python, I could run it directly on my GitHub page, making it easier to share with others.\n\n\nVP-search trees for cgMLST sequences\nVP-search trees for cgMLST sequences\nThis is a project I completed for Statens Serum Institut. The goal was to develop a theoretical approach for more efficient searches in their database for cgMLST analyses. I ended up creating an adaptation of VP-search trees based on Hamming distance. Due to the significant number of missing values in the sequences, I had to modify the method and prove some minor bounds.\nI implemented this in Python, making it usable for their system.\nThe department had a database with the data but conducted data processing in Python. Therefore, it might be more efficient to write code that worked closer to the database. Consequently, the report structure became a bit unconventional.\nI wrote extensive documentation for all functions and implemented everything from scratch to ensure it could be adapted to different programming languages where Python libraries might not be flexible.\nI also conducted speed testing on a smaller, published dataset to showcase how the implementation could be evaluated.\n\n\nMixture of K scaled and shifted t distributions\nMixture of K scaled and shifted t distributions\nThe implementation was created using a combination of R and C++ via the Rcpp library. The report was written in RMarkdown.\nThis project is based on an assignment from one of my classes at KU. I enjoyed it because it had a nice mixture of theoretical calculations, numerical methods, and coding. When I first worked on it, I encountered many problems due to the steep gradient. It was rewarding to revisit it and learn how to handle these challenges. I also got to use C++ and see how it improved computation time.\nThis was one of those projects where the final product was very clean, but the process involved a lot of troubleshooting and learning about program interactions, which was a lot of fun.\nFor example, I used C++ overloaded functions, but due to R not allowing functions with the same name, I ran into issues. When I tested my R implementation with a set output, it worked, and when I tested my C++ implementation, it also worked. It’s easy to understand once you figure it out, but it was challenging until then.\nA small note: this project is a bit technical. If you’ve stumbled upon it and want some intuition about what’s going on, I recommend starting by looking at Gaussian mixtures. Since Gaussian mixtures have closed-form solutions, the expressions are much simpler, which makes understanding the intuition easier.\nFor t-distributions, there is no closed form—or at least I couldn’t derive one—so I had to use numerical methods to compensate. This is why the project ends up focusing heavily on implementing fast code using C++. It also involves addressing numerical issues such as unstable gradients and explaining why the function is not convex. If it were convex, I would have used Newton’s method.\nThis challenge was also what made the project interesting to me. Anyone can fit a Gaussian mixture, which is why it’s so widely used. However, tackling numerical methods and figuring out how to implement solutions when the expressions don’t cooperate is a central skill I wanted to develop."
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "I’m interested in the topics of economics, machine learning(prediction), statistics(inference), and coding."
  },
  {
    "objectID": "about.html#my-background",
    "href": "about.html#my-background",
    "title": "About",
    "section": "My background",
    "text": "My background\nMaster of Science (statistics)\nBachelor math economics\nBoth from University of Copenhagen(KU)"
  },
  {
    "objectID": "Bee_a_Spelling_Guinness.html",
    "href": "Bee_a_Spelling_Guinness.html",
    "title": "Projects",
    "section": "",
    "text": "Here are some of my projects:\n\nMixture of K scaled and shifted t distributions\n\nMixture of K scaled and shifted t distributions\n\nThe implementation is made using a combination of R and C++ via the Rcpp library.\n\n\nVP-search trees for cgMLST sequences\n\nVP-search trees for cgMLST sequences\n\nThe implementation is made in python and the report is written in jupyter notebooks."
  },
  {
    "objectID": "docs/projects.html",
    "href": "docs/projects.html",
    "title": "Projects",
    "section": "",
    "text": "Here are some of my projects:\n\nMixture of K scaled and shifted t distributions\n\nMixture of K scaled and shifted t distributions\n\nThe implementation is made using a combination of R and C++ via the Rcpp library.\n\n\nVP-search trees for cgMLST sequences\n\nVP-search trees for cgMLST sequences\n\nThe implementation is made in python and the report is written in jupyter notebooks."
  },
  {
    "objectID": "aplications.html",
    "href": "aplications.html",
    "title": "Applications",
    "section": "",
    "text": "For now, this site contains only one application built with Shiny. I may extend it in the future if I create more."
  },
  {
    "objectID": "aplications.html#about",
    "href": "aplications.html#about",
    "title": "Applications",
    "section": "About",
    "text": "About\nThis is a interactive app made to, help/improve player’s of New York times Spelling Bee.\nIn the spelling bee, the player is given seven letters. One letter is marked in yellow.\nThe goal is to make as many words as possible from the seven letters. Every word should contain the yellow letter.\nScoring\n\nA word of 4 letters earns one point.\nWords longer than 4 letters earn additional points (the exact amount is to be determined).\n\nThe dictionary used is provided Here under an open license.\nThe Spelling Bee uses a list of curated words. The dictionary is more like a reference for how words are spelled. For example, “AAAA” might appear in the dictionary but is unlikely to be included in the Spelling Bee.\nThere may also be words that are offensive or outdated. While they are correctly spelled, they probably won’t appear in the Spelling Bee."
  },
  {
    "objectID": "aplications.html#version-with-the-code",
    "href": "aplications.html#version-with-the-code",
    "title": "Applications",
    "section": "Version with the code",
    "text": "Version with the code\nHere is a version where the code can be seen\n#| '!! shinylive warning !!': |\n#|   shinylive does not work in self-contained HTML documents.\n#|   Please set `embed-resources: false` in your metadata.\n#| standalone: true\n#| viewerHeight: 800\n#| components: [editor, viewer]\n\nfrom shiny import *\n# For plot\nimport matplotlib.pyplot as plt\n# Get all words in the english diconary\nimport numpy as np\nimport requests\n# URL of the text file on GitHub\nurl = \"https://raw.githubusercontent.com/dwyl/english-words/refs/heads/master/words.txt\"\n\n# Fetch the file content\nresponse = requests.get(url)\n\nif response.status_code == 200:\n    # Read the content of the file\n    file_content = response.text\n    # Split the content into a list of words\n    words_list = file_content.splitlines()\n    print(words_list)\nelse:\n    print(\"Failed to retrieve the file:\", response.status_code)\n\ndef check_word_canidat_early_stopping(\n        word:str,\n        yellow_chr:chr,\n        chr_list:list):\n    \"\"\"\n    This function return True ore False.\n    To be valid candidat a get true retrun, the input word\n    need to contain the yellow chr, and can not contain other chr that yellow and chr from the list of charater list\n    \n    Args:\n        word (str): The word that need to be ckecked.\n        yellow_chr (chr): a chr that all word must contain\n        chr_list (list): a list of chr that the word can be contain in.\n    Returns:\n        bool: True ore False based on if the word forfiels the conditions\n   \n    \"\"\"\n    lover_yellow =yellow_chr.lower()\n    return_obj=False\n    is_word_combination_of_chr_list=False\n    is_yellow_chr_contained= False\n    lower_chars = [char.lower() for char in chr_list]\n    \n    for letter in word:\n        is_letter_contained= letter.lower() in lower_chars\n        if (is_letter_contained==False):\n            is_word_combination_of_chr_list=False\n            break\n        else:\n            is_word_combination_of_chr_list=True\n        if (is_yellow_chr_contained==False):\n            is_yellow_chr_contained=(lover_yellow==letter.lower())\n    \n    if(is_word_combination_of_chr_list==True and is_yellow_chr_contained==True):\n        return_obj =True\n    return return_obj\n\n\n\ndef get_word_candidates(\n        word_list:list,\n        yellow_chr: chr,\n        chr_list:list,\n        min_word_length:int = 4):\n    \"\"\"\n    This returns list containg alle candidat words, for the spelling bee game.\n\n    All word contain the yellow letter, and consist of combination yello and letter from the letter list.\n    All words is longer ore equal to min_word_length\n    \n    Args:\n        word_list (list): a list with string containg words to serach though\n        yellow_chr (chr): all word in return should contain this letter\n        chr_list (list): a list of chr that can be conatin a word in return\n    Returns:\n        list: a list of strings. all word should be combination of yellow chr and letter from the list.\n        \n    \"\"\"\n    return_objet = []\n    index_list=[] #this list contais the index of wich words is potensiel words in the index list.\n    allowed_chartes= chr_list + [yellow_chr]\n    # len word is not calculated but store in the type string so it fast to check if len of the word is les than min first\n    for i in range(len(word_list)):\n        word_for_examination=word_list[i]\n        if(len(word_for_examination)&gt;=min_word_length):\n            if(check_word_canidat_early_stopping(word_for_examination,yellow_chr,allowed_chartes)==True):\n                return_objet.append(word_for_examination)\n                index_list.append(i)\n    return(return_objet)\n\n\n# Generat plots\n\ndef get_len_word_list(words_list:int):\n    list_len=[]\n    for word in words_list: list_len.append(len(word))\n    return list_len\n\n\n\n\n# Define the app UI\napp_ui = ui.page_fluid(\n    ui.input_selectize(\"yellow_chr\", \"Choose one yellow letter\", \n                       [\"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\", \"H\", \"I\", \"J\", \"K\", \"L\", \"M\", \"N\", \"O\", \"P\", \"Q\", \"R\", \"S\", \"T\", \"U\", \"V\", \"W\", \"X\", \"Y\", \"Z\"], \n                       multiple=False),\n    ui.output_text_verbatim(\"yellow_chr_output\"),\n    ui.input_selectize(\"grey_chr\", \"Choose six grey letters\", \n                       [\"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\", \"H\", \"I\", \"J\", \"K\", \"L\", \"M\", \"N\", \"O\", \"P\", \"Q\", \"R\", \"S\", \"T\", \"U\", \"V\", \"W\", \"X\", \"Y\", \"Z\"], \n                       multiple=True),\n    ui.output_text_verbatim(\"grey_chr_output\"),\n    ui.output_text_verbatim(\"len_data_txt\"),\n    ui.output_plot(\"plot\"),\n    ui.output_ui(\"output_content\"),\n    ui.input_switch(\"switch\", \"Show word results\", False),  \n    ui.output_text_verbatim(\"word_list_output\")\n)\n\n# Define the app server logic\ndef server(input, output, session):\n    @reactive.Calc\n    def dataset():\n        # This function returns a dataset when 6 grey letters are selected\n        if len(input.grey_chr()) == 6:\n            return get_word_candidates(words_list, input.yellow_chr(),list(input.grey_chr()))\n        else:\n            return []\n    @reactive.Calc\n    def len_data():\n        len_data=get_len_word_list(dataset())\n        return len_data\n        \n    @output\n    @render.text\n    def yellow_chr_output():\n        return f\"The chosen yellow letter is {input.yellow_chr()}\"\n    @output\n    @render.text\n    def grey_chr_output():\n        if len(input.grey_chr()) != 6:\n            return f\"You need to choose 6 grey letters; currently, you have chosen {len(input.grey_chr())}.\"\n        else:\n            return \"You have chosen 6 grey letters.\"\n    @output\n    @render.text\n    def len_data_txt():\n        ret_ob=\"The data has not bin computed\"\n        if(len(input.grey_chr())==6):\n            ret_ob=f\"There are {len(dataset())} possible words with 4 or more letters\"\n        return ret_ob\n    @output\n    @render.plot(alt=\"A histogram of dataset values\")\n    def plot():    \n        fig, ax = plt.subplots()\n        if len(input.grey_chr()) == 6:\n            unique_values, counts = np.unique(len_data(), return_counts=True)\n            ax.bar(unique_values, counts, color='skyblue', edgecolor='black')\n            ax.set_title(\"Histogram of Word Candidates\")\n            ax.set_xlabel(\"Length of word\")\n            ax.set_ylabel(\"Count\")\n        else:\n            ax.text(0.5, 0.5, \"Please select 6 grey letters\", horizontalalignment='center', verticalalignment='center')\n        return fig\n    @output\n    @render.text\n    def word_list_output():\n        ret_ob=\"\"\n        if(input.switch()==True):\n            ret_ob=\"\\n\".join(dataset())\n        return ret_ob\n        \n    \n\napp = App(app_ui, server)"
  },
  {
    "objectID": "aplications.html#made-with-shiny-for-python-shiny-live",
    "href": "aplications.html#made-with-shiny-for-python-shiny-live",
    "title": "Applications",
    "section": "Made with Shiny for Python (Shiny Live)",
    "text": "Made with Shiny for Python (Shiny Live)\nThis application is created using Shiny for Python (Shiny Live). There is also an R version available.\nWhat makes the Shiny Live version so appealing is that it allows embedding Python code into WebAssembly. This application runs Python directly from your personal computer, with the dictionary downloaded from a GitHub link.\nThe library support is somewhat limited.\nFor small projects that should be accessible to the public, I like Shiny Live because it doesn’t require hosting a server for the backend.\nEstially the backend runs on you pc.\nTheir is som drawback, every aplication need the data to load in seperatly. Alle code and data is exeable for the user, documentasion is spars. It hard to debug, since it reaktiv programing."
  },
  {
    "objectID": "applications.html",
    "href": "applications.html",
    "title": "Applications",
    "section": "",
    "text": "For now, this site contains only one application built with Shiny. I may extend it in the future if I create more."
  },
  {
    "objectID": "applications.html#about",
    "href": "applications.html#about",
    "title": "Applications",
    "section": "About",
    "text": "About\nThis is a interactive app made to, help/improve player’s of New York times Spelling Bee.\nIn the spelling bee, the player is given seven letters. One letter is marked in yellow.\nThe goal is to make as many words as possible from the seven letters. Every word should contain the yellow letter.\nScoring\n\nA word of 4 letters earns one point.\nWords longer than 4 letters earn additional points (the exact amount is to be determined).\n\nThe dictionary used is provided Here under an open license.\nThe Spelling Bee uses a list of curated words. The dictionary is more like a reference for how words are spelled. For example, “AAAA” might appear in the dictionary but is unlikely to be included in the Spelling Bee.\nThere may also be words that are offensive or outdated. While they are correctly spelled, they probably won’t appear in the Spelling Bee.\n#| '!! shinylive warning !!': |\n#|   shinylive does not work in self-contained HTML documents.\n#|   Please set `embed-resources: false` in your metadata.\n#| standalone: true\n#| viewerHeight: 800\n\n\nfrom shiny import *\n# For plot\nimport matplotlib.pyplot as plt\n# Get all words in the english diconary\nimport numpy as np\nimport requests\n# URL of the text file on GitHub\nurl = \"https://raw.githubusercontent.com/dwyl/english-words/refs/heads/master/words.txt\"\n\n# Fetch the file content\nresponse = requests.get(url)\n\nif response.status_code == 200:\n    # Read the content of the file\n    file_content = response.text\n    # Split the content into a list of words\n    words_list = file_content.splitlines()\n    print(words_list)\nelse:\n    print(\"Failed to retrieve the file:\", response.status_code)\n\ndef check_word_canidat_early_stopping(\n        word:str,\n        yellow_chr:chr,\n        chr_list:list):\n    \"\"\"\n    This function returns True or False.\n    To be a valid candidate for a True return, the input word \n    must contain the yellow character and cannot contain any characters \n    other than the yellow character and characters from the provided character list.\n    Args:\n        word (str): The word to be checked.\n        yellow_chr (str): A character that all valid words must contain.\n        chr_list (list): A list of characters that the word is allowed to contain.\n    Returns:\n        bool: True or False depending on whether the word fulfills the conditions.\n\n    \"\"\"\n    lover_yellow =yellow_chr.lower()\n    return_obj=False\n    is_word_combination_of_chr_list=False\n    is_yellow_chr_contained= False\n    lower_chars = [char.lower() for char in chr_list]\n    \n    for letter in word:\n        is_letter_contained= letter.lower() in lower_chars\n        if (is_letter_contained==False):\n            is_word_combination_of_chr_list=False\n            break\n        else:\n            is_word_combination_of_chr_list=True\n        if (is_yellow_chr_contained==False):\n            is_yellow_chr_contained=(lover_yellow==letter.lower())\n    \n    if(is_word_combination_of_chr_list==True and is_yellow_chr_contained==True):\n        return_obj =True\n    return return_obj\n\n\n\ndef get_word_candidates(\n        word_list:list,\n        yellow_chr: chr,\n        chr_list:list,\n        min_word_length:int = 4):\n    \"\"\"\n    This returns list containg alle candidat words, for the spelling bee game.\n\n    All word contain the yellow letter, and consist of combination yello and letter from the letter list.\n    All words is longer ore equal to min_word_length\n    \n    Args:\n        word_list (list): a list with string containg words to serach though\n        yellow_chr (chr): all word in return should contain this letter\n        chr_list (list): a list of chr that can be conatin a word in return\n    Returns:\n        list: a list of strings. all word should be combination of yellow chr and letter from the list.\n        \n    \"\"\"\n    return_objet = []\n    index_list=[] #this list contais the index of wich words is potensiel words in the index list.\n    allowed_chartes= chr_list + [yellow_chr]\n    # len word is not calculated but store in the type string so it fast to check if len of the word is les than min first\n    for i in range(len(word_list)):\n        word_for_examination=word_list[i]\n        if(len(word_for_examination)&gt;=min_word_length):\n            if(check_word_canidat_early_stopping(word_for_examination,yellow_chr,allowed_chartes)==True):\n                return_objet.append(word_for_examination)\n                index_list.append(i)\n    return(return_objet)\n\n\n# Generat plots\n\ndef get_len_word_list(words_list:int):\n    list_len=[]\n    for word in words_list: list_len.append(len(word))\n    return list_len\n\n\n\n\n# Define the app UI\napp_ui = ui.page_fluid(\n    ui.input_selectize(\"yellow_chr\", \"Choose one yellow letter\", \n                       [\"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\", \"H\", \"I\", \"J\", \"K\", \"L\", \"M\", \"N\", \"O\", \"P\", \"Q\", \"R\", \"S\", \"T\", \"U\", \"V\", \"W\", \"X\", \"Y\", \"Z\"], \n                       multiple=False),\n    ui.output_text_verbatim(\"yellow_chr_output\"),\n    ui.input_selectize(\"grey_chr\", \"Choose six grey letters\", \n                       [\"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\", \"H\", \"I\", \"J\", \"K\", \"L\", \"M\", \"N\", \"O\", \"P\", \"Q\", \"R\", \"S\", \"T\", \"U\", \"V\", \"W\", \"X\", \"Y\", \"Z\"], \n                       multiple=True),\n    ui.output_text_verbatim(\"grey_chr_output\"),\n    ui.output_text_verbatim(\"len_data_txt\"),\n    ui.output_plot(\"plot\"),\n    ui.output_ui(\"output_content\"),\n    ui.input_switch(\"switch\", \"Show word results\", False),  \n    ui.output_text_verbatim(\"word_list_output\")\n)\n\n# Define the app server logic\ndef server(input, output, session):\n    @reactive.Calc\n    def dataset():\n        # This function returns a dataset when 6 grey letters are selected\n        if len(input.grey_chr()) == 6:\n            return get_word_candidates(words_list, input.yellow_chr(),list(input.grey_chr()))\n        else:\n            return []\n    @reactive.Calc\n    def len_data():\n        len_data=get_len_word_list(dataset())\n        return len_data\n        \n    @output\n    @render.text\n    def yellow_chr_output():\n        return f\"The chosen yellow letter is {input.yellow_chr()}\"\n    @output\n    @render.text\n    def grey_chr_output():\n        if len(input.grey_chr()) != 6:\n            return f\"You need to choose 6 grey letters; currently, you have chosen {len(input.grey_chr())}.\"\n        else:\n            return \"You have chosen 6 grey letters.\"\n    @output\n    @render.text\n    def len_data_txt():\n        ret_ob=\"The data has not bin computed\"\n        if(len(input.grey_chr())==6):\n            ret_ob=f\"There are {len(dataset())} possible words with 4 or more letters\"\n        return ret_ob\n    @output\n    @render.plot(alt=\"A histogram of dataset values\")\n    def plot():    \n        fig, ax = plt.subplots()\n        if len(input.grey_chr()) == 6:\n            unique_values, counts = np.unique(len_data(), return_counts=True)\n            ax.bar(unique_values, counts, color='skyblue', edgecolor='black')\n            ax.set_title(\"Histogram of Word Candidates\")\n            ax.set_xlabel(\"Length of word\")\n            ax.set_ylabel(\"Count\")\n        else:\n            ax.text(0.5, 0.5, \"Please select 6 grey letters\", horizontalalignment='center', verticalalignment='center')\n        return fig\n    @output\n    @render.text\n    def word_list_output():\n        ret_ob=\"\"\n        if(input.switch()==True):\n            ret_ob=\"\\n\".join(dataset())\n        return ret_ob\n        \n    \n\napp = App(app_ui, server)"
  },
  {
    "objectID": "applications.html#version-with-the-code",
    "href": "applications.html#version-with-the-code",
    "title": "Applications",
    "section": "Version with the code",
    "text": "Version with the code\nHere is a version where the code can be seen\n#| '!! shinylive warning !!': |\n#|   shinylive does not work in self-contained HTML documents.\n#|   Please set `embed-resources: false` in your metadata.\n#| standalone: true\n#| viewerHeight: 800\n#| components: [editor, viewer]\n\nfrom shiny import *\n# For plot\nimport matplotlib.pyplot as plt\n# Get all words in the english diconary\nimport numpy as np\nimport requests\n# URL of the text file on GitHub\nurl = \"https://raw.githubusercontent.com/dwyl/english-words/refs/heads/master/words.txt\"\n\n# Fetch the file content\nresponse = requests.get(url)\n\nif response.status_code == 200:\n    # Read the content of the file\n    file_content = response.text\n    # Split the content into a list of words\n    words_list = file_content.splitlines()\n    print(words_list)\nelse:\n    print(\"Failed to retrieve the file:\", response.status_code)\n\ndef check_word_canidat_early_stopping(\n        word:str,\n        yellow_chr:chr,\n        chr_list:list):\n    \"\"\"\n    This function returns True or False.\n    To be a valid candidate for a True return, the input word \n    must contain the yellow character and cannot contain any characters \n    other than the yellow character and characters from the provided character list.\n    Args:\n        word (str): The word to be checked.\n        yellow_chr (str): A character that all valid words must contain.\n        chr_list (list): A list of characters that the word is allowed to contain.\n    Returns:\n        bool: True or False depending on whether the word fulfills the conditions.\n\n    \"\"\"\n    lover_yellow =yellow_chr.lower()\n    return_obj=False\n    is_word_combination_of_chr_list=False\n    is_yellow_chr_contained= False\n    lower_chars = [char.lower() for char in chr_list]\n    \n    for letter in word:\n        is_letter_contained= letter.lower() in lower_chars\n        if (is_letter_contained==False):\n            is_word_combination_of_chr_list=False\n            break\n        else:\n            is_word_combination_of_chr_list=True\n        if (is_yellow_chr_contained==False):\n            is_yellow_chr_contained=(lover_yellow==letter.lower())\n    \n    if(is_word_combination_of_chr_list==True and is_yellow_chr_contained==True):\n        return_obj =True\n    return return_obj\n\n\n\ndef get_word_candidates(\n        word_list:list,\n        yellow_chr: chr,\n        chr_list:list,\n        min_word_length:int = 4):\n    \"\"\"\n    This returns list containg alle candidat words, for the spelling bee game.\n\n    All word contain the yellow letter, and consist of combination yellow and letter from the letter list.\n    All words is longer ore equal to min_word_length\n    \n    Args:\n        word_list (list): a list with string containg words to serach though\n        yellow_chr (chr): all word in return should contain this letter\n        chr_list (list): a list of chr that can be conatin a word in return\n    Returns:\n        list: a list of strings. all word should be combination of yellow chr and letter from the list.\n        \n    \"\"\"\n    return_objet = []\n    index_list=[] #this list contais the index of wich words is potensiel words in the index list.\n    allowed_chartes= chr_list + [yellow_chr]\n    # len word is not calculated but store in the type string so it fast to check if len of the word is les than min first\n    for i in range(len(word_list)):\n        word_for_examination=word_list[i]\n        if(len(word_for_examination)&gt;=min_word_length):\n            if(check_word_canidat_early_stopping(word_for_examination,yellow_chr,allowed_chartes)==True):\n                return_objet.append(word_for_examination)\n                index_list.append(i)\n    return(return_objet)\n\n\n# Generat plots\n\ndef get_len_word_list(words_list:int):\n    list_len=[]\n    for word in words_list: list_len.append(len(word))\n    return list_len\n\n\n\n\n# Define the app UI\napp_ui = ui.page_fluid(\n    ui.input_selectize(\"yellow_chr\", \"Choose one yellow letter\", \n                       [\"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\", \"H\", \"I\", \"J\", \"K\", \"L\", \"M\", \"N\", \"O\", \"P\", \"Q\", \"R\", \"S\", \"T\", \"U\", \"V\", \"W\", \"X\", \"Y\", \"Z\"], \n                       multiple=False),\n    ui.output_text_verbatim(\"yellow_chr_output\"),\n    ui.input_selectize(\"grey_chr\", \"Choose six grey letters\", \n                       [\"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\", \"H\", \"I\", \"J\", \"K\", \"L\", \"M\", \"N\", \"O\", \"P\", \"Q\", \"R\", \"S\", \"T\", \"U\", \"V\", \"W\", \"X\", \"Y\", \"Z\"], \n                       multiple=True),\n    ui.output_text_verbatim(\"grey_chr_output\"),\n    ui.output_text_verbatim(\"len_data_txt\"),\n    ui.output_plot(\"plot\"),\n    ui.output_ui(\"output_content\"),\n    ui.input_switch(\"switch\", \"Show word results\", False),  \n    ui.output_text_verbatim(\"word_list_output\")\n)\n\n# Define the app server logic\ndef server(input, output, session):\n    @reactive.Calc\n    def dataset():\n        # This function returns a dataset when 6 grey letters are selected\n        if len(input.grey_chr()) == 6:\n            return get_word_candidates(words_list, input.yellow_chr(),list(input.grey_chr()))\n        else:\n            return []\n    @reactive.Calc\n    def len_data():\n        len_data=get_len_word_list(dataset())\n        return len_data\n        \n    @output\n    @render.text\n    def yellow_chr_output():\n        return f\"The chosen yellow letter is {input.yellow_chr()}\"\n    @output\n    @render.text\n    def grey_chr_output():\n        if len(input.grey_chr()) != 6:\n            return f\"You need to choose 6 grey letters; currently, you have chosen {len(input.grey_chr())}.\"\n        else:\n            return \"You have chosen 6 grey letters.\"\n    @output\n    @render.text\n    def len_data_txt():\n        ret_ob=\"The data has not bin computed\"\n        if(len(input.grey_chr())==6):\n            ret_ob=f\"There are {len(dataset())} possible words with 4 or more letters\"\n        return ret_ob\n    @output\n    @render.plot(alt=\"A histogram of dataset values\")\n    def plot():    \n        fig, ax = plt.subplots()\n        if len(input.grey_chr()) == 6:\n            unique_values, counts = np.unique(len_data(), return_counts=True)\n            ax.bar(unique_values, counts, color='skyblue', edgecolor='black')\n            ax.set_title(\"Histogram of Word Candidates\")\n            ax.set_xlabel(\"Length of word\")\n            ax.set_ylabel(\"Count\")\n        else:\n            ax.text(0.5, 0.5, \"Please select 6 grey letters\", horizontalalignment='center', verticalalignment='center')\n        return fig\n    @output\n    @render.text\n    def word_list_output():\n        ret_ob=\"\"\n        if(input.switch()==True):\n            ret_ob=\"\\n\".join(dataset())\n        return ret_ob\n        \n    \n\napp = App(app_ui, server)"
  },
  {
    "objectID": "applications.html#made-with-shiny-for-python-shiny-live",
    "href": "applications.html#made-with-shiny-for-python-shiny-live",
    "title": "Applications",
    "section": "Made with Shiny for Python (Shiny Live)",
    "text": "Made with Shiny for Python (Shiny Live)\nThis application is created using Shiny for Python (Shiny Live). There is also an R version available.\nWhat makes the Shiny Live version so appealing is that it allows embedding Python code into WebAssembly. This application runs Python directly from your personal computer, with the dictionary downloaded from a GitHub link.\nThe library support is somewhat limited.\nFor small projects that should be accessible to the public, I like Shiny Live because it doesn’t require hosting a server for the backend.\nEstially the backend runs on you pc.\nTheir is som drawback, every aplication need the data to load in seperatly. Alle code and data is exeable for the user, documentasion is spars. It hard to debug, since it reaktiv programing.\nBut overall, being able to create applications without needing to host a server is pretty cool."
  },
  {
    "objectID": "Projects/A Toy Model for Market Dynamics Building a Agent-Based Frameworks.html",
    "href": "Projects/A Toy Model for Market Dynamics Building a Agent-Based Frameworks.html",
    "title": "A Toy Model for Market Dynamics: Building a Agent-Based Frameworks",
    "section": "",
    "text": "I am applying for a job where the primary task involves working on and implementing agent-based simulations. It has been a while since I last worked with object-oriented coding, so I thought I would brush up on my basic skills by creating a small project based on a simple market simulation.\nMy background is primarily in mathematics, economics, and statistics. At the computer science department at KU, there don’t seem to be many courses that focus on agent-based simulation approaches. However, I recall attending a talk organized by the group “Kritiske Politter” a long time ago. The speaker was a professor from the physics department who, as a hobby, created simulations of markets. His main critique of traditional economics was the reliance on steady-state assumptions, which are quite common in the field. He argued that natural systems often exhibit fluctuations, even when they are in balance.\n\n\nTo give an example: If one simulates an island with rabbits and foxes, there will be fluctuations in the populations. When there are many rabbits, the fox population increases, which then leads to a decline in rabbits. This, in turn, causes a decline in foxes, allowing the rabbit population to grow again, and the cycle continues. In this case, a perfect equilibrium is unrealistic; instead, the equilibrium is a range in which the number of foxes and rabbits alternates over time.\nI find this field fascinating. One of my primary concerns is not just creating rational agents but making them realistic. In my economics courses, a lot of different techniques and models were presented to answer central questions. The argument often was that if these models capture the essence of some problem, they are useful. To some extent, I agree with this argument. However, I disagree with making assumptions solely for the purpose of solving the steady state of a system. This is why the agent-based approach is so interesting to me—it resembles the way physicists would approach a problem.\n\n\n\nIn this small project, I will attempt to create a basic framework for simulating agents. When I was first introduced to object-oriented programming, we worked on something similar to the rabbit-and-fox scenario.\nThe Code Will Be Written in Python Since the company appears to use Python, I will carry out the simulation using this language.\nIf I were building an extensive simulation framework for agents, I might consider using C++ due to its performance advantages. The key idea behind agent-based simulations is the interaction between agents, which makes it an iterative process. While Python may not be the fastest for such loops, parallelized programming could improve performance.\nAlthough I have experience with parallelization in R, I imagine Python offers more sophisticated methods. For instance, dividing agents into clusters that interact and processing these simultaneously could be an interesting approach. Learning and implementing this would be a valuable experience, although it exceeds my current skill level. In R, parallelization often involves copying the entire dataset to avoid writing conflicts; it would be exciting to explore more efficient solutions.\n\n\n\nIn summary, agent-based approaches are incredibly interesting and would be enjoyable to work on. I believe this problem provides a great opportunity to refresh my object-oriented programming skills. These simulations rely on Monte Carlo methods as their underlying mathematical approach, which makes them challenging to test."
  },
  {
    "objectID": "Projects/A Toy Model for Market Dynamics Building a Agent-Based Frameworks.html#rabbits-and-foxes",
    "href": "Projects/A Toy Model for Market Dynamics Building a Agent-Based Frameworks.html#rabbits-and-foxes",
    "title": "A Toy Model for Market Dynamics: Building a Agent-Based Frameworks",
    "section": "",
    "text": "To give an example: If one simulates an island with rabbits and foxes, there will be fluctuations in the populations. When there are many rabbits, the fox population increases, which then leads to a decline in rabbits. This, in turn, causes a decline in foxes, allowing the rabbit population to grow again, and the cycle continues. In this case, a perfect equilibrium is unrealistic; instead, the equilibrium is a range in which the number of foxes and rabbits alternates over time.\nI find this field fascinating. One of my primary concerns is not just creating rational agents but making them realistic. In my economics courses, a lot of different techniques and models were presented to answer central questions. The argument often was that if these models capture the essence of some problem, they are useful. To some extent, I agree with this argument. However, I disagree with making assumptions solely for the purpose of solving the steady state of a system. This is why the agent-based approach is so interesting to me—it resembles the way physicists would approach a problem."
  },
  {
    "objectID": "Projects/A Toy Model for Market Dynamics Building a Agent-Based Frameworks.html#this-project",
    "href": "Projects/A Toy Model for Market Dynamics Building a Agent-Based Frameworks.html#this-project",
    "title": "A Toy Model for Market Dynamics: Building a Agent-Based Frameworks",
    "section": "",
    "text": "In this small project, I will attempt to create a basic framework for simulating agents. When I was first introduced to object-oriented programming, we worked on something similar to the rabbit-and-fox scenario.\nThe Code Will Be Written in Python Since the company appears to use Python, I will carry out the simulation using this language.\nIf I were building an extensive simulation framework for agents, I might consider using C++ due to its performance advantages. The key idea behind agent-based simulations is the interaction between agents, which makes it an iterative process. While Python may not be the fastest for such loops, parallelized programming could improve performance.\nAlthough I have experience with parallelization in R, I imagine Python offers more sophisticated methods. For instance, dividing agents into clusters that interact and processing these simultaneously could be an interesting approach. Learning and implementing this would be a valuable experience, although it exceeds my current skill level. In R, parallelization often involves copying the entire dataset to avoid writing conflicts; it would be exciting to explore more efficient solutions."
  },
  {
    "objectID": "Projects/A Toy Model for Market Dynamics Building a Agent-Based Frameworks.html#summary",
    "href": "Projects/A Toy Model for Market Dynamics Building a Agent-Based Frameworks.html#summary",
    "title": "A Toy Model for Market Dynamics: Building a Agent-Based Frameworks",
    "section": "",
    "text": "In summary, agent-based approaches are incredibly interesting and would be enjoyable to work on. I believe this problem provides a great opportunity to refresh my object-oriented programming skills. These simulations rely on Monte Carlo methods as their underlying mathematical approach, which makes them challenging to test."
  },
  {
    "objectID": "Projects/A Toy Model for Market Dynamics Building a Agent-Based Frameworks.html#the-environment-strøget",
    "href": "Projects/A Toy Model for Market Dynamics Building a Agent-Based Frameworks.html#the-environment-strøget",
    "title": "A Toy Model for Market Dynamics: Building a Agent-Based Frameworks",
    "section": "The Environment (Strøget)",
    "text": "The Environment (Strøget)\nSince the company is located in Copenhagen, I thought it would be fun to use the city center as the topic of this exercise.\nIf we limit Strøget to the area between “Storkespringvandet” and the entrance near City Hall, we can imagine it as a long corridor with shops on both sides. To simplify, we’ll assume there’s one shop at each location along this corridor.\nThus, the environment can be represented as a long chain of shops. Agents can start from either end and pass through the corridor."
  },
  {
    "objectID": "Projects/A Toy Model for Market Dynamics Building a Agent-Based Frameworks.html#the-shopper",
    "href": "Projects/A Toy Model for Market Dynamics Building a Agent-Based Frameworks.html#the-shopper",
    "title": "A Toy Model for Market Dynamics: Building a Agent-Based Frameworks",
    "section": "The Shopper",
    "text": "The Shopper\nFrom personal experience, it seems that nobody goes to Strøget to buy necessities—it’s more about purchasing nice-to-have items and doing light shopping. I’ll assume people arrive at Strøget with a certain amount of money (cash) they want to spend.\nI created some preference classes, such as Food, Clothing, and Books. By making these preferences into classes, I can tailor purchase patterns for each category.\nFood: This is consumed only once, meaning if someone buys food, they won’t purchase it again. Cash: The shopper’s cash balance decreases with each purchase. Position: Tracks where the shopper is located in the chain of shops. Presence: Indicates whether the shopper is still on the street. When a shopper encounters a shop that matches their preferences, they will buy something with a given probability—but only if they can afford it."
  },
  {
    "objectID": "Projects/A Toy Model for Market Dynamics Building a Agent-Based Frameworks.html#the-shop-agents",
    "href": "Projects/A Toy Model for Market Dynamics Building a Agent-Based Frameworks.html#the-shop-agents",
    "title": "A Toy Model for Market Dynamics: Building a Agent-Based Frameworks",
    "section": "The Shop Agents",
    "text": "The Shop Agents\nShop agents will offer products at a given price in specific categories. To keep things simple, each shop offers one product in one category.\nSimulations The simulation is managed via the Street class.\nTo simplify, shops are ordered by their placement along the street. I haven’t implemented checks for errors in the ordering since this is just a toy example.\nThe simulation progresses with a tick function, allowing the system to update step by step.\nOverall Overall, I like this construction. Instead of storing positions in a variable, I could have moved the object itself or used pointers to save computational costs related to copying."
  },
  {
    "objectID": "Projects/A Toy Model for Market Dynamics Building a Agent-Based Frameworks.html#classes",
    "href": "Projects/A Toy Model for Market Dynamics Building a Agent-Based Frameworks.html#classes",
    "title": "A Toy Model for Market Dynamics: Building a Agent-Based Frameworks",
    "section": "Classes",
    "text": "Classes\n\n\nCode\nimport random\n\nclass Shop:\n    def __init__(self, placement: int, category: str, price: int):\n        \"\"\"\n        Represents a shop in the market.\n        :param placement: Position of the shop along the market.\n        :param category: The type of items sold by the shop (e.g., 'Food', 'Books').\n        :param price: The price of the items sold.\n        \"\"\"\n        self.placement = placement\n        self.category = category\n        self.price = price\n        self.units_sold=0\n    \n    def sold_unit(self):\n        self.units_sold +=1\n\n    def turnover(self):\n        return self.units_sold*self.price\n\n\"\"\"The belov class represent prefference a cosumer could have\"\"\"\nclass food:\n    def __init__(self,type,buy_prop,have_eaten=False,units_bought=0):\n        self.type=type\n        self.buy_prop=buy_prop\n        self.have_eaten=have_eaten\n        self.units_bought=units_bought\n    def will_buy(self):\n        return_obj=False\n        if(self.have_eaten==False):\n            return_obj= random.random()&lt; self.buy_prop\n            if(return_obj==True):\n                self.have_eaten=True\n                self.units_bought+=1\n        return (return_obj)\n\nclass cloth:\n    def __init__(self,type,buy_prop,units_bought=0):\n        self.type=type\n        self.buy_prop=buy_prop\n        self.units_bought=units_bought\n    def will_buy(self): \n        return_obj=random.random()&lt; self.buy_prop\n        if return_obj== True: self.units_bought+=1\n        return return_obj\n\nclass book:\n    def __init__(self,type,buy_prop,units_bought=0):\n        self.type=type\n        self.buy_prop=buy_prop\n        self.units_bought=units_bought\n    def will_buy(self):\n        return_obj=random.random()&lt; self.buy_prop\n        if return_obj== True: self.units_bought+=1\n        return return_obj\n\n\nclass Shopper:\n    def __init__(self,placement: int,direction,cash: float,preferences: list):\n        \"\"\"\n        Represents a shopper in the market.\n        :param placement: Current position of the shopper.\n        :param direction: Direction of movement (-1 for left, 1 for right).\n        :param cash: Amount of money the shopper has.\n        :param gender: Gender of the shopper (used for preferences).\n        :param preferences: Dictionary of categories and buy probabilities.\n        \"\"\"\n        self.placement = placement\n        self.direction = direction\n        self.cash = cash\n        self.preferences = preferences  \n        self.has_eaten = False\n        self.has_eaten_dessert = False\n        self.shoper_pressent_at_market=True\n        \n    def update_position(self):\n        \"\"\"This function update the postion of the shopper and updates if their are shoper pressent at market\"\"\"\n        self.placement=self.placement+self.direction\n        return\n    \n    def visit_shop(self, shop: Shop):\n        \"\"\"\n        Interact with a shop and decide whether to buy.\n        :param shop: The shop to interact with.\n        \"\"\"\n        # find if shope is in the prefrence\n        did_buy=False\n        for index in range(len(self.preferences)):\n            if(self.preferences[index].type==shop.category):\n                if(shop.price&lt;self.cash):\n                    did_buy=self.preferences[index].will_buy()\n            if (did_buy==True):\n                self.cash=self.cash-shop.price\n                shop.sold_unit()\n        self.update_position()\n        return did_buy\n        \n    \nclass shopping_street:\n    def __init__(self,list_of_shops,list_of_shopers):\n        # List of shoops should be ordere by placement\n        self.list_of_shops=list_of_shops\n        self.list_of_shopers=list_of_shopers\n        self.min=list_of_shops[0].placement\n        self.max=list_of_shops[(len(list_of_shops)-1)].placement\n\n    def run_tick_shopper(self,index):\n        \"\"\"This function will run one iteration of the simulation for a given agent\"\"\"\n        if (self.list_of_shopers[index].shoper_pressent_at_market)==True:\n            self.list_of_shopers[index].visit_shop(self.list_of_shops[index])\n        if(self.min&lt;(self.list_of_shopers[index].placement) or self.list_of_shopers[index].placement&lt;(self.max)):\n            self.list_of_shopers[index].shoper_pressent_at_market=False\n    def run_tick(self):\n        \"\"\"This function will run one iteration of the simulation for all agents\"\"\"\n        for ind in range(len(self.list_of_shopers)):\n            self.run_tick_shopper(ind)\n    def get_unit(self):\n        unit_sold=0\n        for ind in range(len(self.list_of_shops)):\n            unit_sold +=self.list_of_shops[ind].units_sold\n        return(unit_sold)\n    def get_total_turnover(self):\n        turnover=0\n        for ind in range(len(self.list_of_shops)):\n            turnover +=self.list_of_shops[ind].turnover()\n        return(turnover)"
  },
  {
    "objectID": "Projects/A Toy Model for Market Dynamics Building a Agent-Based Frameworks.html#unit-testing",
    "href": "Projects/A Toy Model for Market Dynamics Building a Agent-Based Frameworks.html#unit-testing",
    "title": "A Toy Model for Market Dynamics: Building a Agent-Based Frameworks",
    "section": "Unit Testing",
    "text": "Unit Testing\nBelow, my Unit test, can be seen\n\n\nCode\n# unit test\nimport  unittest\n\ndef test_Shop_class():\n    test_Shop = Shop(2,\"men cloth\",100)\n    test_Shop.sold_unit()\n    assert(test_Shop.units_sold==1)\n    assert(test_Shop.units_sold*test_Shop.price==test_Shop.turnover())\n    \n    return\ntest_Shop_class()\n\ndef test_cloth_class():\n    test_cloth = cloth(type=\"men cloth\", buy_prop=1)\n    assert test_cloth.will_buy() == True\n    assert test_cloth.units_bought==1\n    return\ntest_cloth_class()\ndef test_book_class():\n    test_book = book(type=\"book store\", buy_prop=1)\n    assert test_book.will_buy() == True\n    assert test_book.units_bought==1\n    return\ntest_book_class()\ndef test_food_class():\n    test_food=food(type=\"Fastfood\",buy_prop=1)\n    assert(test_food.have_eaten)==False\n    # Should buy since buy prop = 1 \n    assert(test_food.will_buy()==True)\n    #\n    assert(test_food.units_bought==1)\n    # have eaten = True \n    assert(test_food.have_eaten)==True\n    #should not buy since have eaten\n    assert(test_food.will_buy()==False)\n    return \ntest_food_class()\n    \ndef test_Shopper_class():\n    test_Shop = Shop(2,\"men cloth\",100)\n    test_food=food(type=\"Fastfood\",buy_prop=1)\n    test_cloth = cloth(type=\"men cloth\", buy_prop=1)\n    test_Shopper=Shopper(placement=2,direction=-1,cash=1000,preferences=[test_food,test_cloth])\n    assert test_Shopper.placement==2\n    # The visit function should change the cash and update the units sold if the shop is in the preferences\n    assert(test_Shopper.visit_shop(test_Shop))\n    assert test_Shopper.placement==1\n    assert test_Shopper.preferences[1].units_bought==1\n    assert test_Shopper.cash==1000-test_Shop.price\n    assert test_Shopper.placement==1\n    # Test of shope not in preferences\n    test_Shop_2=Shop(1,\"book\",100)\n    assert test_Shopper.visit_shop(test_Shop_2) ==False\n    # since\n    assert test_Shopper.cash==1000-test_Shop.price\n    assert test_Shopper.placement==0\n    return \n    \ntest_Shopper_class()\n\ndef test_shopping_street_class():\n    test_Shop_1 = Shop(2,\"men cloth\",100)\n    test_shop_2=Shop(1,\"book\",50) \n    test_food=food(type=\"Fastfood\",buy_prop=1)\n    test_cloth = cloth(type=\"men cloth\", buy_prop=1)\n    test_Shopper_1=Shopper(placement=2,direction=-1,cash=1000,preferences=[test_food,test_cloth])\n    test_Shopper_2=Shopper(placement=1,direction=1,cash=1000,preferences=[test_food,test_cloth])\n    test_shopping_street=shopping_street(list_of_shops=[test_Shop_1,test_shop_2],list_of_shopers=[test_Shopper_1,test_Shopper_2])\n    \n    # No book should be hold sold \n    # The mens cloth should be sold\n    assert test_shopping_street.list_of_shopers[0].placement==2\n    assert test_shopping_street.list_of_shopers[1].placement==1\n    assert test_shopping_street.list_of_shops[0].units_sold==0\n    assert test_shopping_street.list_of_shops[1].units_sold==0\n    test_shopping_street.run_tick()\n    assert test_shopping_street.list_of_shopers[0].placement==1\n    assert test_shopping_street.list_of_shopers[1].placement==2\n    assert test_shopping_street.list_of_shops[0].units_sold==1\n    assert test_shopping_street.list_of_shops[1].units_sold==0\n    test_shopping_street.run_tick()\n    test_shopping_street.run_tick()\n    assert test_shopping_street.list_of_shopers[0].placement==0\n    assert test_shopping_street.list_of_shopers[1].placement==3\n    assert test_shopping_street.list_of_shops[0].units_sold==2\n    assert test_shopping_street.list_of_shops[1].units_sold==0\n    test_shopping_street.run_tick()\n    assert test_shopping_street.list_of_shopers[0].placement==0\n    assert test_shopping_street.list_of_shopers[1].placement==3\n    assert test_shopping_street.list_of_shops[0].units_sold==2\n    assert test_shopping_street.list_of_shops[1].units_sold==0\n    assert test_shopping_street.get_total_turnover()==2*100\n    assert test_shopping_street.get_unit()\n\n    return\ntest_shopping_street_class()"
  },
  {
    "objectID": "Projects/A Toy Model for Market Dynamics Building a Agent-Based Frameworks.html#simulation",
    "href": "Projects/A Toy Model for Market Dynamics Building a Agent-Based Frameworks.html#simulation",
    "title": "A Toy Model for Market Dynamics: Building a Agent-Based Frameworks",
    "section": "Simulation",
    "text": "Simulation\nIn this code, I implemented a small simulation to validate the framework. I plotted the units sold and the turnover. Since this is a Monte Carlo simulation, there is no theoretical distribution for comparison\n\n\nCode\nimport matplotlib as plt\n\ndef simulate_street():\n    shops = [\n        Shop(placement=0, category=\"food\", price=50),\n        Shop(placement=1, category=\"cloth\", price=200),\n        Shop(placement=2, category=\"book\", price=150),\n        Shop(placement=3, category=\"food\", price=100),\n        Shop(placement=4, category=\"cloth\", price=300),\n        Shop(placement=5, category=\"book\", price=250)\n        ]\n    ticks=len(shops)\n    preferences_1 = [\n        food(type=\"food\", buy_prop=0.8),\n        cloth(type=\"cloth\", buy_prop=0.5),\n        book(type=\"book\", buy_prop=0.6)\n        ]\n    preferences_2 = [\n        food(type=\"food\", buy_prop=0.6),\n        cloth(type=\"cloth\", buy_prop=0.3),\n        book(type=\"book\", buy_prop=0.9)\n        ]\n    shoppers = [\n        Shopper(placement=0, direction=1, cash=500, preferences=random.choice([preferences_1, preferences_2])),\n        Shopper(placement=5, direction=-1, cash=800, preferences=random.choice([preferences_1, preferences_2])),\n        Shopper(placement=2, direction=1, cash=300, preferences=random.choice([preferences_1, preferences_2]))\n        ]\n    # Initialize the shopping street\n    street = shopping_street(list_of_shops=shops, list_of_shopers=shoppers)\n    for _ in range(ticks):\n        street.run_tick()\n\n    # Return a dictionary with the results\n    return {\n        \"Total_units\": street.get_unit(),\n        \"Total_turnover\": street.get_total_turnover()\n    }\n\n\n#plot distibution of sale and and units sold\nTotal_units=[]\nTotal_turnover=[]\nfor i in range(100):\n    sim_obj=simulate_street()\n    Total_units.append(sim_obj[\"Total_units\"])\n    Total_turnover.append(sim_obj[\"Total_turnover\"])\n\n\n\n\nimport matplotlib.pyplot as plt\n\n\n\n# Create two subplots\nfig, axes = plt.subplots(2, 1, figsize=(8, 10))  # 2 rows, 1 column\n\n# Histogram for List A\naxes[0].hist(Total_units, bins=5, color='blue', alpha=0.7)\naxes[0].set_title('Histogram of Total units')\naxes[0].set_xlabel('Value')\naxes[0].set_ylabel('Frequency')\n\n# Histogram for List B\naxes[1].hist(Total_turnover, bins=5, color='orange', alpha=0.7)\naxes[1].set_title('Histogram of Total turnover')\naxes[1].set_xlabel('Value')\naxes[1].set_ylabel('Frequency')\n\n# Adjust layout\nplt.tight_layout()\n\n# Show plots\nplt.show()"
  },
  {
    "objectID": "Projects/A Toy Model for Market Dynamics Building a Agent-Based Frameworks.html#downstream-effects",
    "href": "Projects/A Toy Model for Market Dynamics Building a Agent-Based Frameworks.html#downstream-effects",
    "title": "A Toy Model for Market Dynamics: Building a Agent-Based Frameworks",
    "section": "Downstream Effects",
    "text": "Downstream Effects\nI believe downstream effects would be simpler to implement. To track these efficiently, I would use a directed graph or a reactive graph (as described in Mastering Shiny). The reactive graph approach could be more efficient for managing dependencies and dynamic changes in the system."
  },
  {
    "objectID": "Projects/A Toy Model for Market Dynamics Building a Agent-Based Frameworks.html#parallelization-challenges",
    "href": "Projects/A Toy Model for Market Dynamics Building a Agent-Based Frameworks.html#parallelization-challenges",
    "title": "A Toy Model for Market Dynamics: Building a Agent-Based Frameworks",
    "section": "Parallelization Challenges",
    "text": "Parallelization Challenges\nA minor technical detail: as the code is written now, parallelizing the simulation would be challenging. Although the shoppers do not interact directly, they interact with the same shops. This creates a potential issue when writing to shared variables, such as the units sold in a shop. If multiple shoppers update this variable simultaneously, errors could occur.\nI am particularly interested in learning how to address these kinds of problems effectively. For example, using locks or other concurrency control methods might help, but exploring more sophisticated solutions could be valuable."
  }
]