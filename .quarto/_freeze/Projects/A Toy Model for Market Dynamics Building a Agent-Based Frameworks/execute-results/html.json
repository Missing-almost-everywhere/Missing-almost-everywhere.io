{
  "hash": "6eb61b916ed04bce906532154e468b96",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"A Toy Model for Market Dynamics: Building a Agent-Based Frameworks\"\nformat:\n  html:\n    code-fold: true\n---\n\n\n\n# Introduction\nI am applying for a job where the primary task involves working on and implementing agent-based simulations.\n\nMy background is primarily in mathematics, economics, and statistics. At the computer science department at KU, there don’t seem to be many courses that adopt a simulated agent-based approach. However, I remember attending a talk organized by the group \"Kritiske Politter\" a long time ago. The talk featured a professor from the physics department who, as a hobby, created simulations of markets. His main critique was the reliance on steady-state assumptions, which are common in economics. He argued that natural systems often exhibit fluctuations, even when they are balanced.\n\n## Rabbits and Foxes\nTo give an example:\nIf one simulates an island with rabbits and foxes, there will be fluctuations in the populations. When there are many rabbits, the fox population increases, which then leads to a decline in rabbits. This, in turn, causes a decline in foxes, allowing the rabbit population to grow again, and the cycle continues. In this case, a perfect equilibrium is unrealistic; instead, the equilibrium is a range in which the number of foxes and rabbits alternates over time.\n\nI find this field fascinating. One of my primary concerns is not just creating rational agents but making them realistic. In my economics courses, a lot of different techniques and models were presented to answer central questions. The argument often was that if these models capture the essence of some problem, they are useful. To some extent, I agree with this argument. However, I disagree with making assumptions solely for the purpose of solving the steady state of a system. This is why the agent-based approach is so interesting to me—it resembles the way physicists would approach a problem.\n\n## This Project\nIn this small project, I will attempt to create a basic framework for simulating agents. When I was first introduced to object-oriented programming, we worked on something similar to the rabbit-and-fox scenario.\n\nThe Code Will Be Written in Python\nSince the company appears to use Python, I will carry out the simulation using this language.\n\nIf I were building an extensive simulation framework for agents, I might consider using C++ due to its performance advantages. The key idea behind agent-based simulations is the interaction between agents, which makes it an iterative process. While Python may not be the fastest for such loops, parallelized programming could improve performance.\n\nAlthough I have experience with parallelization in R, I imagine Python offers more sophisticated methods. For instance, dividing agents into clusters that interact and processing these simultaneously could be an interesting approach. Learning and implementing this would be a valuable experience, although it exceeds my current skill level. In R, parallelization often involves copying the entire dataset to avoid writing conflicts; it would be exciting to explore more efficient solutions.\n\n## Summary\nIn summary, agent-based approaches are incredibly interesting and would be enjoyable to work on. I thought this problem would be a good way to brush up on my object-oriented programming skills.\nThe underlying mathematical approach for these simulations is Monte Carlo simulations.\n\n\n# A Simple Simulation of Markets\nThere is likely a lot of theory on agent-based simulations, but since I am new to this field, I’ll start with a simple simulation of a market. This is a toy example, so if you’re reading this and think some deep theoretical insights can be drawn from this model (a common approach in economic modeling), remember: I HAVE NO DATA.\n\nDuring my microeconomics courses, I worked extensively on building theoretical models and creating narratives or conclusions based on them—without ever looking at real data. While it’s relatively easy to create models of agents, building realistic agents is far more challenging.\n\nIf you are interested in examples of non-rational behavior in humans, I recommend reading Nudge or Predictably Irrational. The latter describes experiments in detail, which I personally enjoy.\n\nSince this job is based in Copenhagen, I’ll simulate \"Strøget,\" the historic shopping district in the city center.\n\n## The Environment (Strøget)\nSince the company is located in Copenhagen, I thought it would be fun to use the city center as the topic of this exercise.\n\nIf we limit Strøget to the area between “Storkespringvandet” and the entrance near City Hall, we can imagine it as a long corridor with shops on both sides. To simplify, we’ll assume there’s one shop at each location along this corridor.\n\nThus, the environment can be represented as a long chain of shops. Agents can start from either end and pass through the corridor.\n\n## The Shopper\nFrom personal experience, it seems that nobody goes to Strøget to buy necessities—it’s more about purchasing nice-to-have items and doing light shopping. I’ll assume people arrive at Strøget with a certain amount of money (cash) they want to spend.\n\nI created some preference classes, such as Food, Clothing, and Books. By making these preferences into classes, I can tailor purchase patterns for each category.\n\nFood: This is consumed only once, meaning if someone buys food, they won’t purchase it again.\nCash: The shopper’s cash balance decreases with each purchase.\nPosition: Tracks where the shopper is located in the chain of shops.\nPresence: Indicates whether the shopper is still on the street.\nWhen a shopper encounters a shop that matches their preferences, they will buy something with a given probability—but only if they can afford it.\n\n## The Shop Agents\nShop agents will offer products at a given price in specific categories. To keep things simple, each shop offers one product in one category.\n\nSimulations\nThe simulation is managed via the Street class.\n\nTo simplify, shops are ordered by their placement along the street. I haven’t implemented checks for errors in the ordering since this is just a toy example.\n\nThe simulation progresses with a tick function, allowing the system to update step by step.\n\nOverall\nOverall, I like this construction. Instead of storing positions in a variable, I could have moved the object itself or used pointers to save computational costs related to copying.\n\n\n# Implementasion\nIn this section, I have written the code for the implementation.\n## Classes\nBelow, my classes and the central construction can be found.\n\n::: {#c6abd748 .cell execution_count=1}\n``` {.python .cell-code}\nimport random\n\nclass Shop:\n    def __init__(self, placement: int, category: str, price: int):\n        \"\"\"\n        Represents a shop in the market.\n        :param placement: Position of the shop along the market.\n        :param category: The type of items sold by the shop (e.g., 'Food', 'Books').\n        :param price: The price of the items sold.\n        \"\"\"\n        self.placement = placement\n        self.category = category\n        self.price = price\n        self.units_sold=0\n    \n    def sold_unit(self):\n        self.units_sold +=1\n\n    def turnover(self):\n        return self.units_sold*self.price\n\n\"\"\"The belov class represent prefference a cosumer could have\"\"\"\nclass food:\n    def __init__(self,type,buy_prop,have_eaten=False,units_bought=0):\n        self.type=type\n        self.buy_prop=buy_prop\n        self.have_eaten=have_eaten\n        self.units_bought=units_bought\n    def will_buy(self):\n        return_obj=False\n        if(self.have_eaten==False):\n            return_obj= random.random()< self.buy_prop\n            if(return_obj==True):\n                self.have_eaten=True\n                self.units_bought+=1\n        return (return_obj)\n\nclass cloth:\n    def __init__(self,type,buy_prop,units_bought=0):\n        self.type=type\n        self.buy_prop=buy_prop\n        self.units_bought=units_bought\n    def will_buy(self): \n        return_obj=random.random()< self.buy_prop\n        if return_obj== True: self.units_bought+=1\n        return return_obj\n\nclass book:\n    def __init__(self,type,buy_prop,units_bought=0):\n        self.type=type\n        self.buy_prop=buy_prop\n        self.units_bought=units_bought\n    def will_buy(self):\n        return_obj=random.random()< self.buy_prop\n        if return_obj== True: self.units_bought+=1\n        return return_obj\n\n\nclass Shopper:\n    def __init__(self,placement: int,direction,cash: float,preferences: list):\n        \"\"\"\n        Represents a shopper in the market.\n        :param placement: Current position of the shopper.\n        :param direction: Direction of movement (-1 for left, 1 for right).\n        :param cash: Amount of money the shopper has.\n        :param gender: Gender of the shopper (used for preferences).\n        :param preferences: Dictionary of categories and buy probabilities.\n        \"\"\"\n        self.placement = placement\n        self.direction = direction\n        self.cash = cash\n        self.preferences = preferences  \n        self.has_eaten = False\n        self.has_eaten_dessert = False\n        self.shoper_pressent_at_market=True\n        \n    def update_position(self):\n        \"\"\"This function update the postion of the shopper and updates if their are shoper pressent at market\"\"\"\n        self.placement=self.placement+self.direction\n        return\n    \n    def visit_shop(self, shop: Shop):\n        \"\"\"\n        Interact with a shop and decide whether to buy.\n        :param shop: The shop to interact with.\n        \"\"\"\n        # find if shope is in the prefrence\n        did_buy=False\n        for index in range(len(self.preferences)):\n            if(self.preferences[index].type==shop.category):\n                if(shop.price<self.cash):\n                    did_buy=self.preferences[index].will_buy()\n            if (did_buy==True):\n                self.cash=self.cash-shop.price\n                shop.sold_unit()\n        self.update_position()\n        return did_buy\n        \n    \nclass shopping_street:\n    def __init__(self,list_of_shops,list_of_shopers):\n        # List of shoops should be ordere by placement\n        self.list_of_shops=list_of_shops\n        self.list_of_shopers=list_of_shopers\n        self.min=list_of_shops[0].placement\n        self.max=list_of_shops[(len(list_of_shops)-1)].placement\n\n    def run_tick_shopper(self,index):\n        \"\"\"This function will run one iteration of the simulation for a given agent\"\"\"\n        if (self.list_of_shopers[index].shoper_pressent_at_market)==True:\n            self.list_of_shopers[index].visit_shop(self.list_of_shops[index])\n        if(self.min<(self.list_of_shopers[index].placement) or self.list_of_shopers[index].placement<(self.max)):\n            self.list_of_shopers[index].shoper_pressent_at_market=False\n    def run_tick(self):\n        \"\"\"This function will run one iteration of the simulation for all agents\"\"\"\n        for ind in range(len(self.list_of_shopers)):\n            self.run_tick_shopper(ind)\n    def get_unit(self):\n        unit_sold=0\n        for ind in range(len(self.list_of_shops)):\n            unit_sold +=self.list_of_shops[ind].units_sold\n        return(unit_sold)\n    def get_total_turnover(self):\n        turnover=0\n        for ind in range(len(self.list_of_shops)):\n            turnover +=self.list_of_shops[ind].turnover()\n        return(turnover)\n\n```\n:::\n\n\n## Unit Testing\nBelow, my Unit test, can be seen\n\n::: {#70bf9bac .cell execution_count=2}\n``` {.python .cell-code}\n# unit test\nimport  unittest\n\ndef test_Shop_class():\n    test_Shop = Shop(2,\"men cloth\",100)\n    test_Shop.sold_unit()\n    assert(test_Shop.units_sold==1)\n    assert(test_Shop.units_sold*test_Shop.price==test_Shop.turnover())\n    \n    return\ntest_Shop_class()\n\ndef test_cloth_class():\n    test_cloth = cloth(type=\"men cloth\", buy_prop=1)\n    assert test_cloth.will_buy() == True\n    assert test_cloth.units_bought==1\n    return\ntest_cloth_class()\ndef test_book_class():\n    test_book = book(type=\"book store\", buy_prop=1)\n    assert test_book.will_buy() == True\n    assert test_book.units_bought==1\n    return\ntest_book_class()\ndef test_food_class():\n    test_food=food(type=\"Fastfood\",buy_prop=1)\n    assert(test_food.have_eaten)==False\n    # Should buy since buy prop = 1 \n    assert(test_food.will_buy()==True)\n    #\n    assert(test_food.units_bought==1)\n    # have eaten = True \n    assert(test_food.have_eaten)==True\n    #should not buy since have eaten\n    assert(test_food.will_buy()==False)\n    return \ntest_food_class()\n    \ndef test_Shopper_class():\n    test_Shop = Shop(2,\"men cloth\",100)\n    test_food=food(type=\"Fastfood\",buy_prop=1)\n    test_cloth = cloth(type=\"men cloth\", buy_prop=1)\n    test_Shopper=Shopper(placement=2,direction=-1,cash=1000,preferences=[test_food,test_cloth])\n    assert test_Shopper.placement==2\n    # The visit function should change the cash and update the units sold if the shop is in the preferences\n    assert(test_Shopper.visit_shop(test_Shop))\n    assert test_Shopper.placement==1\n    assert test_Shopper.preferences[1].units_bought==1\n    assert test_Shopper.cash==1000-test_Shop.price\n    assert test_Shopper.placement==1\n    # Test of shope not in preferences\n    test_Shop_2=Shop(1,\"book\",100)\n    assert test_Shopper.visit_shop(test_Shop_2) ==False\n    # since\n    assert test_Shopper.cash==1000-test_Shop.price\n    assert test_Shopper.placement==0\n    return \n    \ntest_Shopper_class()\n\ndef test_shopping_street_class():\n    test_Shop_1 = Shop(2,\"men cloth\",100)\n    test_shop_2=Shop(1,\"book\",50) \n    test_food=food(type=\"Fastfood\",buy_prop=1)\n    test_cloth = cloth(type=\"men cloth\", buy_prop=1)\n    test_Shopper_1=Shopper(placement=2,direction=-1,cash=1000,preferences=[test_food,test_cloth])\n    test_Shopper_2=Shopper(placement=1,direction=1,cash=1000,preferences=[test_food,test_cloth])\n    test_shopping_street=shopping_street(list_of_shops=[test_Shop_1,test_shop_2],list_of_shopers=[test_Shopper_1,test_Shopper_2])\n    \n    # No book should be hold sold \n    # The mens cloth should be sold\n    assert test_shopping_street.list_of_shopers[0].placement==2\n    assert test_shopping_street.list_of_shopers[1].placement==1\n    assert test_shopping_street.list_of_shops[0].units_sold==0\n    assert test_shopping_street.list_of_shops[1].units_sold==0\n    test_shopping_street.run_tick()\n    assert test_shopping_street.list_of_shopers[0].placement==1\n    assert test_shopping_street.list_of_shopers[1].placement==2\n    assert test_shopping_street.list_of_shops[0].units_sold==1\n    assert test_shopping_street.list_of_shops[1].units_sold==0\n    test_shopping_street.run_tick()\n    test_shopping_street.run_tick()\n    assert test_shopping_street.list_of_shopers[0].placement==0\n    assert test_shopping_street.list_of_shopers[1].placement==3\n    assert test_shopping_street.list_of_shops[0].units_sold==2\n    assert test_shopping_street.list_of_shops[1].units_sold==0\n    test_shopping_street.run_tick()\n    assert test_shopping_street.list_of_shopers[0].placement==0\n    assert test_shopping_street.list_of_shopers[1].placement==3\n    assert test_shopping_street.list_of_shops[0].units_sold==2\n    assert test_shopping_street.list_of_shops[1].units_sold==0\n    assert test_shopping_street.get_total_turnover()==2*100\n    assert test_shopping_street.get_unit()\n\n    return\ntest_shopping_street_class()\n```\n:::\n\n\n## Simulation\nIn this code, I created a small simulation to ensure the framework works. I have plotted the units sold and the turnover. Since this functions as a Monte Carlo simulation, there is no theoretical result to compare the distribution with\n\n::: {#d2e12db0 .cell execution_count=3}\n``` {.python .cell-code}\nimport matplotlib as plt\n\ndef simulate_street():\n    shops = [\n        Shop(placement=0, category=\"food\", price=50),\n        Shop(placement=1, category=\"cloth\", price=200),\n        Shop(placement=2, category=\"book\", price=150),\n        Shop(placement=3, category=\"food\", price=100),\n        Shop(placement=4, category=\"cloth\", price=300),\n        Shop(placement=5, category=\"book\", price=250)\n        ]\n    ticks=len(shops)\n    preferences_1 = [\n        food(type=\"food\", buy_prop=0.8),\n        cloth(type=\"cloth\", buy_prop=0.5),\n        book(type=\"book\", buy_prop=0.6)\n        ]\n    preferences_2 = [\n        food(type=\"food\", buy_prop=0.6),\n        cloth(type=\"cloth\", buy_prop=0.3),\n        book(type=\"book\", buy_prop=0.9)\n        ]\n    shoppers = [\n        Shopper(placement=0, direction=1, cash=500, preferences=random.choice([preferences_1, preferences_2])),\n        Shopper(placement=5, direction=-1, cash=800, preferences=random.choice([preferences_1, preferences_2])),\n        Shopper(placement=2, direction=1, cash=300, preferences=random.choice([preferences_1, preferences_2]))\n        ]\n    # Initialize the shopping street\n    street = shopping_street(list_of_shops=shops, list_of_shopers=shoppers)\n    for _ in range(ticks):\n        street.run_tick()\n\n    # Return a dictionary with the results\n    return {\n        \"Total_units\": street.get_unit(),\n        \"Total_turnover\": street.get_total_turnover()\n    }\n\n\n#plot distibution of sale and and units sold\nTotal_units=[]\nTotal_turnover=[]\nfor i in range(100):\n    sim_obj=simulate_street()\n    Total_units.append(sim_obj[\"Total_units\"])\n    Total_turnover.append(sim_obj[\"Total_turnover\"])\n\n\n\n\nimport matplotlib.pyplot as plt\n\n\n\n# Create two subplots\nfig, axes = plt.subplots(2, 1, figsize=(8, 10))  # 2 rows, 1 column\n\n# Histogram for List A\naxes[0].hist(Total_units, bins=5, color='blue', alpha=0.7)\naxes[0].set_title('Histogram of Total units')\naxes[0].set_xlabel('Value')\naxes[0].set_ylabel('Frequency')\n\n# Histogram for List B\naxes[1].hist(Total_turnover, bins=5, color='orange', alpha=0.7)\naxes[1].set_title('Histogram of Total turnover')\naxes[1].set_xlabel('Value')\naxes[1].set_ylabel('Frequency')\n\n# Adjust layout\nplt.tight_layout()\n\n# Show plots\nplt.show()\n```\n\n::: {.cell-output .cell-output-display}\n![](A Toy Model for Market Dynamics Building a Agent-Based Frameworks_files/figure-html/cell-4-output-1.png){width=758 height=950}\n:::\n:::\n\n\n# No Conclusions from the Model\nAs stated at the beginning, this project was designed purely as an exercise in thinking about good structures for this type of model, rather than drawing any conclusions from the simulation.\n# Technical Notes and Suggestions for Improvement\nOne potential improvement to the structure I created is how data is stored in the objects' classes.\n\nCurrently, all data is encapsulated within individual objects, which works for tracking properties specific to each agent or shop. However, if I were interested in aggregated data—such as the total units sold—I would need to compute this after each tick by iterating through all the relevant objects.\n\nA more efficient approach could involve maintaining a centralized summary of key metrics during the simulation. For example:\n\n- Total Units Sold: Incremented directly when a sale occurs.\n- Revenue by Category: Updated in real time when a product is purchased.\n\nThis way, aggregated data would be readily available without requiring extra computation after each tick. It would also make it easier to monitor and analyze trends as the simulation progresses.\n\n\nWhen building simulations or using object-oriented programming, many of the structures can be designed in various ways. For example, the buy function could be implemented as part of the shopper agent or as part of the environment.\n\nMaintaining a well-organized structure is crucial, especially when managing dynamic effects, which can quickly become complex. This is particularly true in economic systems where actors are trained to consider both upstream and downstream effects.\n\n## Downstream Effects\nI believe downstream effects would be simpler to implement. To track these efficiently, I would use a directed graph or a reactive graph (as described in Mastering Shiny). The reactive graph approach could be more efficient for managing dependencies and dynamic changes in the system.\n\n## Parallelization Challenges\nA minor technical detail: as the code is written now, parallelizing the simulation would be challenging. Although the shoppers do not interact directly, they interact with the same shops. This creates a potential issue when writing to shared variables, such as the units sold in a shop. If multiple shoppers update this variable simultaneously, errors could occur.\n\nI am particularly interested in learning how to address these kinds of problems effectively. For example, using locks or other concurrency control methods might help, but exploring more sophisticated solutions could be valuable.\n\n",
    "supporting": [
      "A Toy Model for Market Dynamics Building a Agent-Based Frameworks_files"
    ],
    "filters": [],
    "includes": {}
  }
}